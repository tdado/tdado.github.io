<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-09-18T17:47:31+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Thirza Dado</title><subtitle>An amazing website.</subtitle><author><name>Thirza Dado</name></author><entry><title type="html">Neural decoding w/ synthesized reality</title><link href="http://localhost:4000/hyper/" rel="alternate" type="text/html" title="Neural decoding w/ synthesized reality" /><published>2022-01-22T00:00:00+01:00</published><updated>2022-01-22T00:00:00+01:00</updated><id>http://localhost:4000/hyper</id><content type="html" xml:base="http://localhost:4000/hyper/"><![CDATA[<h3 id="hyperrealistic-reconstruction-of-perceived-faces-from-fmri-data">HYperrealistic reconstruction of PERceived faces from fMRI data</h3>

<p>2022, 22 January</p>

<p><img src="/assets/images/top.png" alt="Top" />
<em>Stimuli (top row) and their reconstructions from brain data (bottom row).</em></p>

<p>Neural decoding seeks to find what information about a perceived external stimulus is present in the corresponding brain response. In particular, the original stimulus can be reconstructed based on brain data alone. This study resulted in the most accurate reconstructions of face perception to date by decoding the brain recordings of two individual participants separately. To get even closer, we repeated this approach with the averaged brain responses.</p>

<p>Here, we show you how we did it.</p>

<h5 id="hyper">HYPER</h5>
<p>In the original paper, two participants in the brain scanner were presented with face stimuli that elicited specific functional responses in their brains. This experiment resulted in a (faces, responses) dataset that taught a decoder to map brain responses to the corresponding faces. This trained decoder could now transform unseen (held-out) brain data back into the perceived stimuli. The model was called HYPER (HYperrealistic reconstruction of PERception).</p>

<p><img src="/assets/images/m1.png" alt="Experiment" />
<em>The face stimulus was presented to the participant in the MRI scanner that recorded the corresponding neural responses. Neural decoding of these responses then reconstructed what the participant was originally seeing.</em></p>

<p>The secret ingredient was the following: the face stimuli were artificially synthesized by the generator network of a progressively grown GAN for faces from randomly sampled latent vectors; the people in the presented images did not really exist. As such, the latents underlying these faces were known (because they were used for generation in the first place) whereas those of real face images can never be directly accessed - only approximated which entails information loss. Note that these results are legitimate reconstructions of visual perception regardless of the nature of the stimuli themselves.</p>

<p><img src="/assets/images/m2.png" alt="Pipeline" />
<em>Schematic workflow of HYPER. A latent is fed to the GAN to generate a face image that is presented to a participant in the MRI scanner. From the recorded brain response to this stimulus, we predict a latent that is also fed to the GAN for (re-)generation.</em></p>

<p>The high resemblance indicates a linear relationship between latents and brain recordings. Simply put, latents and brains effectively captured the same defining stimulus features (e.g., age, gender, hair color, pose) so that latents could be predicted as a linear combination of the brain data and fed to the generator for (re-)generation of what was perceived.</p>

<h5 id="hyperalignment-brainremix">Hyperalignment (brain remix)</h5>

<p>The original study trained a separate decoder for each individual participant. To get even closer to the external stimulus, we can capture the shared neural information across participants by applying an additional preprocessing step to the brain data. This step involves aligning and reslicing the functional brain responses with hyperalignment - a remixing process that iteratively maps brain data of multiple participants to a common functional space. Note that we are working in the functional domain which is about brain function rather than the topography in the anatomical domain. The responses of different brains are now comparable in function and the average brain response per stimulus can be taken to train one general decoder.</p>

<p>All the stimulus-reconstruction pairs in this post result from HYPER with hyperaligned and averaged data.</p>

<p><img src="/assets/images/1.png" alt="Recon1" />
<em>Stimuli (top row) and their reconstructions from brain data (bottom row).</em></p>

<p><img src="/assets/images/2.png" alt="Recon2" />
<em>Stimuli (top row) and their reconstructions from brain data (bottom row).</em></p>

<h3 id="tutorial">Tutorial</h3>
<p>Hyperalignment can be implemented using <a href="http://www.pymvpa.org/">PyMVPA</a>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">!</span><span class="n">apt</span><span class="o">-</span><span class="n">get</span> <span class="n">install</span> <span class="n">swig</span>
<span class="err">!</span><span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">U</span> <span class="n">pymvpa2</span>
<span class="kn">import</span> <span class="nn">mvpa2.datasets</span>
<span class="kn">import</span> <span class="nn">mvpa2.algorithms.hyperalignment</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">def</span> <span class="nf">hyperalignment</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>    
    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>    
    <span class="n">dataset</span> <span class="o">=</span> <span class="p">[</span><span class="n">mvpa2</span><span class="p">.</span><span class="n">datasets</span><span class="p">.</span><span class="n">Dataset</span><span class="p">(</span><span class="n">x_</span><span class="p">)</span> <span class="k">for</span> <span class="n">x_</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]</span>    
    <span class="n">hyperalignment</span> <span class="o">=</span> <span class="n">mvpa2</span><span class="p">.</span><span class="n">algorithms</span><span class="p">.</span><span class="n">hyperalignment</span><span class="p">.</span><span class="n">Hyperalignment</span><span class="p">()(</span><span class="n">dataset</span><span class="p">)</span>    
    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">hyperalignment</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">forward</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="n">j</span><span class="p">]).</span><span class="n">samples</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">))]</span>    
    <span class="k">return</span> <span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
</code></pre></div></div>

<p>Load in the data (publicly accessible in <a href="https://drive.google.com/drive/u/1/folders/1NEblHtlRFvUyD5CA2sqSVfcGlfJBqw_T">Google Drive</a>). The test and training set consist of 36 and 1050 trials of 4096 (flattened) voxel responses, respectively. Concatenate the test and training data before hyperalignment.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"yourpath/data_1.dat"</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">X_tr1</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">X_te1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"yourpath/data_2.dat"</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">X_tr2</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">X_te2</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">X_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">X_te1</span> <span class="o">+</span> <span class="n">X_tr1</span><span class="p">)</span>
<span class="n">X_2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">X_te2</span> <span class="o">+</span> <span class="n">X_tr2</span><span class="p">)</span>
<span class="n">X_hyperaligned</span> <span class="o">=</span> <span class="n">hyperalignment</span><span class="p">(</span><span class="n">X_1</span><span class="p">,</span> <span class="n">X_2</span><span class="p">)</span>
</code></pre></div></div>

<p>Train a neural decoder to predict latents from brain data. This decoder is implemented in MXNet. Let’s import the required libraries.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">!</span><span class="n">pip</span> <span class="n">install</span> <span class="n">mxnet</span><span class="o">-</span><span class="n">cu101</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">mxnet</span> <span class="k">as</span> <span class="n">mx</span>
<span class="kn">from</span> <span class="nn">mxnet</span> <span class="kn">import</span> <span class="n">autograd</span><span class="p">,</span> <span class="n">gluon</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="n">symbol</span>
<span class="kn">from</span> <span class="nn">mxnet.gluon.nn</span> <span class="kn">import</span> <span class="n">Conv2D</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">HybridBlock</span><span class="p">,</span>       
    <span class="n">HybridSequential</span><span class="p">,</span> <span class="n">LeakyReLU</span>
<span class="kn">from</span> <span class="nn">mxnet.gluon.parameter</span> <span class="kn">import</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">mxnet.initializer</span> <span class="kn">import</span> <span class="n">Zero</span>
<span class="kn">from</span> <span class="nn">mxnet.io</span> <span class="kn">import</span> <span class="n">NDArrayIter</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">zscore</span>
</code></pre></div></div>

<p>Below you can find a MXNet implementation of the PGGAN generator. It takes a 512-dimensional latent and transforms it into a 1024 ×1024 RGB image.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Pixelnorm</span><span class="p">(</span><span class="n">HybridBlock</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-8</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Pixelnorm</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">epsilon</span>
    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nd</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">F</span><span class="p">.</span><span class="n">rsqrt</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">square</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">eps</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Bias</span><span class="p">(</span><span class="n">HybridBlock</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Bias</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">shape</span>
        <span class="k">with</span> <span class="bp">self</span><span class="p">.</span><span class="n">name_scope</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"b"</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="n">Zero</span><span class="p">(),</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nd</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">F</span><span class="p">.</span><span class="n">broadcast_add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">b</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="p">:,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">])</span>
<span class="k">class</span> <span class="nc">Block</span><span class="p">(</span><span class="n">HybridSequential</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">in_channels</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Block</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">in_channels</span> <span class="o">=</span> <span class="n">in_channels</span>
        <span class="k">with</span> <span class="bp">self</span><span class="p">.</span><span class="n">name_scope</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">in_channels</span><span class="o">=</span><span class="n">in_channels</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">0.2</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Pixelnorm</span><span class="p">())</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">in_channels</span><span class="o">=</span><span class="n">channels</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">0.2</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Pixelnorm</span><span class="p">())</span>
    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nd</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x</span>
<span class="k">class</span> <span class="nc">Generator</span><span class="p">(</span><span class="n">HybridSequential</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Generator</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__init__</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="p">.</span><span class="n">name_scope</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Pixelnorm</span><span class="p">())</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="mi">8192</span><span class="p">,</span> <span class="n">use_bias</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">in_units</span><span class="o">=</span><span class="mi">512</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Bias</span><span class="p">((</span><span class="mi">512</span><span class="p">,)))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">0.2</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Pixelnorm</span><span class="p">())</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">in_channels</span><span class="o">=</span><span class="mi">512</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">LeakyReLU</span><span class="p">(</span><span class="mf">0.2</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Pixelnorm</span><span class="p">())</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Block</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Block</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Block</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Block</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">512</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Block</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Block</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Block</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Block</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">in_channels</span><span class="o">=</span><span class="mi">16</span><span class="p">))</span>
    <span class="k">def</span> <span class="nf">hybrid_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="p">:</span> <span class="n">Union</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">symbol</span><span class="p">),</span> <span class="n">x</span><span class="p">:</span> <span class="n">nd</span><span class="p">,</span> <span class="n">layer</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nd</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">Reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">x</span><span class="p">)),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">x</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">layer</span> <span class="o">+</span> <span class="mi">7</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span>
        <span class="k">return</span> <span class="n">x</span>
</code></pre></div></div>

<p>A dense (decoding) layer then transforms the 4096-dimensional functional responses into 512-dimensional latents. Only train the weights of this layer and keep the generator weights fixed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">HybridSequential</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_in</span><span class="p">,</span> <span class="n">n_out</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Linear</span><span class="p">,</span> <span class="bp">self</span><span class="p">).</span><span class="n">__init__</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="p">.</span><span class="n">name_scope</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="n">n_out</span><span class="p">,</span> <span class="n">in_units</span><span class="o">=</span><span class="n">n_in</span><span class="p">))</span>
</code></pre></div></div>

<p>Before training, all data have to be transformed to be of type <a href="https://mxnet.apache.org/versions/1.6/api/python/docs/api/ndarray/index.html">NDArray</a> (make sure to also store on GPU if you have access). The weight parameters of the generator (MXNet) can be found on Drive. Note that we are using gradient descent to fit the weights of the dense layer whereas ordinary least squares would yield a similar solution. However, the current setup allows you to experiment and try different things to make more sophisticated models (e.g., predict intermediate layer activations of PGGAN and include this in your loss function).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Set parameters.
</span><span class="n">batch_size</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">max_epoch</span> <span class="o">=</span> <span class="mi">1500</span>
<span class="n">n_lat</span> <span class="o">=</span> <span class="mi">512</span>
<span class="n">n_vox</span> <span class="o">=</span> <span class="mi">4096</span>
<span class="c1"># Make dataset to take batches from during training.
</span><span class="k">def</span> <span class="nf">load_dataset</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">NDArrayIter</span><span class="p">({</span> <span class="s">"x"</span><span class="p">:</span> <span class="n">nd</span><span class="p">.</span><span class="n">stack</span><span class="p">(</span><span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">},</span> <span class="p">{</span> <span class="s">"t"</span><span class="p">:</span> <span class="n">nd</span><span class="p">.</span><span class="n">stack</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="p">},</span> <span class="n">batch_size</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
<span class="c1"># Latents.
</span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"yourpath/data_1.dat"</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">T_tr</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">T_te</span> <span class="o">=</span> <span class="n">pickle</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="c1"># Z-score the brain data.
</span><span class="n">X_te</span> <span class="o">=</span> <span class="n">zscore</span><span class="p">(</span><span class="n">X_hyperaligned</span><span class="p">[:</span><span class="mi">36</span><span class="p">])</span>
<span class="n">X_tr</span> <span class="o">=</span> <span class="n">zscore</span><span class="p">(</span><span class="n">X_hyperaligned</span><span class="p">[</span><span class="mi">36</span><span class="p">:])</span>
<span class="n">train</span> <span class="o">=</span> <span class="n">load_dataset</span><span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">T_tr</span><span class="p">),</span> <span class="n">nd</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">X_tr</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">)</span>
<span class="n">test</span> <span class="o">=</span>  <span class="n">load_dataset</span><span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">T_te</span><span class="p">),</span> <span class="n">nd</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">X_te</span><span class="p">),</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">36</span><span class="p">)</span>
<span class="c1"># Initialize generator.
</span><span class="n">generator</span> <span class="o">=</span> <span class="n">Generator</span><span class="p">()</span>
<span class="n">generator</span><span class="p">.</span><span class="n">load_parameters</span><span class="p">(</span><span class="s">"yourpath/generator.params"</span><span class="p">)</span>
<span class="n">mean_squared_error</span> <span class="o">=</span> <span class="n">gluon</span><span class="p">.</span><span class="n">loss</span><span class="p">.</span><span class="n">L2Loss</span><span class="p">()</span>
<span class="c1"># Initialize linear model.
</span><span class="n">vox_to_lat</span> <span class="o">=</span> <span class="n">Linear</span><span class="p">(</span><span class="n">n_vox</span><span class="p">,</span> <span class="n">n_lat</span><span class="p">)</span>
<span class="n">vox_to_lat</span><span class="p">.</span><span class="n">initialize</span><span class="p">()</span>
<span class="n">trainer</span> <span class="o">=</span> <span class="n">gluon</span><span class="p">.</span><span class="n">Trainer</span><span class="p">(</span><span class="n">vox_to_lat</span><span class="p">.</span><span class="n">collect_params</span><span class="p">(),</span> <span class="s">"Adam"</span><span class="p">,</span> <span class="p">{</span><span class="s">"learning_rate"</span><span class="p">:</span> <span class="mf">0.00001</span><span class="p">,</span> <span class="s">"wd"</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">})</span>
<span class="c1"># Training.
</span><span class="n">epoch</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">results_tr</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">results_te</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">while</span> <span class="n">epoch</span> <span class="o">&lt;</span> <span class="n">max_epoch</span><span class="p">:</span>
    <span class="n">train</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span>
    <span class="n">test</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span>
    <span class="n">loss_tr</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">loss_te</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">batch_tr</span> <span class="ow">in</span> <span class="n">train</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">autograd</span><span class="p">.</span><span class="n">record</span><span class="p">():</span>
            <span class="n">lat_Y</span> <span class="o">=</span> <span class="n">vox_to_lat</span><span class="p">(</span><span class="n">batch_tr</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">loss</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">lat_Y</span><span class="p">,</span> <span class="n">batch_tr</span><span class="p">.</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">loss</span><span class="p">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">trainer</span><span class="p">.</span><span class="n">step</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
        <span class="n">loss_tr</span> <span class="o">+=</span> <span class="n">loss</span><span class="p">.</span><span class="n">mean</span><span class="p">().</span><span class="n">asnumpy</span><span class="p">()</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">batch_te</span> <span class="ow">in</span> <span class="n">test</span><span class="p">:</span>
        <span class="n">lat_Y</span> <span class="o">=</span> <span class="n">vox_to_lat</span><span class="p">(</span><span class="n">batch_te</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">mean_squared_error</span><span class="p">(</span><span class="n">lat_Y</span><span class="p">,</span> <span class="n">batch_te</span><span class="p">.</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">loss_te</span> <span class="o">+=</span> <span class="n">loss</span><span class="p">.</span><span class="n">mean</span><span class="p">().</span><span class="n">asnumpy</span><span class="p">()</span>
    <span class="n">loss_tr_normalized</span> <span class="o">=</span> <span class="n">loss_tr</span> <span class="o">/</span> <span class="n">count</span>
    <span class="n">results_tr</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_tr_normalized</span><span class="p">)</span>
    <span class="n">results_te</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">loss_te</span><span class="p">)</span>
    <span class="n">epoch</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Epoch %i: %.4f / %.4f"</span> <span class="o">%</span> <span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">loss_tr_normalized</span><span class="p">,</span> <span class="n">loss_te</span><span class="p">))</span>
<span class="n">plt</span><span class="p">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">epoch</span><span class="p">),</span> <span class="n">results_tr</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">epoch</span><span class="p">),</span> <span class="n">results_te</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p>After training, reconstruct faces from the test set responses. Note that the test data is not used for training (you only computed the test loss per epoch for plotting purposes) such that the model never encountered this brain data before.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Testing and reconstructing
</span><span class="n">lat_Y</span> <span class="o">=</span> <span class="n">vox_to_lat</span><span class="p">(</span><span class="n">nd</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">X_te</span><span class="p">))</span>
<span class="nb">dir</span> <span class="o">=</span> <span class="s">"yourpath/reconstructions"</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="nb">dir</span><span class="p">):</span>
    <span class="n">os</span><span class="p">.</span><span class="n">mkdir</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">latent</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lat_Y</span><span class="p">):</span>
    <span class="n">face</span> <span class="o">=</span> <span class="n">generator</span><span class="p">(</span><span class="n">latent</span><span class="p">[</span><span class="bp">None</span><span class="p">],</span> <span class="mi">9</span><span class="p">).</span><span class="n">asnumpy</span><span class="p">()</span>
    <span class="n">face</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">clip</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">rint</span><span class="p">(</span><span class="mf">127.5</span> <span class="o">*</span> <span class="n">face</span> <span class="o">+</span> <span class="mf">127.5</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">255.0</span><span class="p">)</span>
    <span class="n">face</span> <span class="o">=</span> <span class="n">face</span><span class="p">.</span><span class="n">astype</span><span class="p">(</span><span class="s">"uint8"</span><span class="p">).</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">Image</span><span class="p">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">face</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">'RGB'</span><span class="p">).</span><span class="n">save</span><span class="p">(</span><span class="nb">dir</span> <span class="o">+</span> <span class="s">"/%d.png"</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
</code></pre></div></div>

<p>In the end, one decoding model was trained on averaged functional neural responses which resulted in face reconstructions spectacularly analogous to the originally perceived faces. This raises the question of how close neural decoding can get to objective reality if we average the brain data of an even larger pool of eyewitnesses.</p>

<p>That’s all folks!</p>

<p><img src="/assets/images/3.png" alt="Recon3" /></p>

<p><img src="/assets/images/4.png" alt="Recon4" />
<em>Stimuli (top row) and their reconstructions from brain data (bottom row).</em></p>

<p>Dado, T., Güçlütürk, Y., Ambrogioni, L. et al. Hyperrealistic neural decoding for reconstructing faces from fMRI activations via the GAN latent space. Sci Rep 12, 141 (2022). https://doi.org/10.1038/s41598-021-03938-w</p>]]></content><author><name>Thirza Dado</name></author><summary type="html"><![CDATA[HYperrealistic reconstruction of PERceived faces from fMRI data]]></summary></entry></feed>